// Exp. in pg. 351
#include<iostream>
#include<stdlib.h>
#include<string>
#include<cmath>
#include<fstream>
#include<sstream>
#include<vector>
#include <iomanip> //for setprecision
using namespace std;
typedef double T;
T kesi_aita_tox(T kesi, T aita, T L, T H1, T H2);
T kesi_aita_toy(T xratio, T aita, T L, T H1, T H2);
T analytical_kesi_subx(T kesi, T aita, T L, T H1, T H2);

int main()
{
	unsigned int IM = 30, JM = 30;
	unsigned int L = 8, H1 = 2, H2 = 4;
	T dkesi = 1./(IM - 1.);
	T daita = 1./(JM - 1.);
	
	vector<vector<T>> grid;

	T kesi, aita;
	for(unsigned int j = 0; j < JM; j++)
		for(unsigned int i = 0; i < IM; i++)
		{
			kesi = i*dkesi;
			aita = j*daita;
			vector<T> gridlocal(2);
			gridlocal[0] = kesi_aita_tox(kesi, aita, L, H1, H2);
			//here x ratio is used instead of x, otherwise we will get a curve on the top boundary
			T xratio = gridlocal[0]/L;
			gridlocal[1] = kesi_aita_toy(xratio, aita, L, H1, H2);
			grid.push_back(gridlocal);
		}
	ostringstream name;
	name<<"grid.dat";
	ofstream out(name.str().c_str());
	out<<"Title=\"Grid generated by using algebraic grid generation techniques\"\n"<<"VARIABLES=\"X\",\"Y\"\n";
	out<<"ZONE T = \"BOX\", I = "<<IM<<", J = "<<JM<<", F = POINT"<<endl;
	for(unsigned int i = 0; i < IM*JM; i++)
		out<<grid[i][0]<<" "<<grid[i][1]<<endl;
}

T kesi_aita_tox(T kesi, T aita, T L, T H1, T H2)
{
	//T y = (H1 + (H2 - H1)/L*kesi)*aita;
	T D = 0.25*L;
	T beta = 5;
	T A = (1./(2.*beta))*log((1.+(exp(beta) - 1.)*(D/L))/(1.+(exp(-beta) - 1.)*(D/L)));
	T x = D*(1. + sinh(beta*(kesi-A))/sinh(beta*A));
	return x;
}
T kesi_aita_toy(T xratio, T aita, T L, T H1, T H2)
{
	T hei = (H1 + (H2 - H1)*xratio);
	T D = 0.5*hei;
	T beta = 5;
	T A = (1./(2.*beta))*log((1.+(exp(beta) - 1.)*(D/hei))/(1.+(exp(-beta) - 1.)*(D/hei)));
	T y = D*(1. + sinh(beta*(aita-A))/sinh(beta*A));
	return y;
}